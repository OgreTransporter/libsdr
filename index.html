<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.9.1"/>
<title>libsdr: A C++ library for software defined radio (SDR).</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { init_search(); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">libsdr
   &#160;<span id="projectnumber">0.1.0</span>
   </div>
   <div id="projectbrief">A simple SDR library</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.9.1 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li class="current"><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
</div><!-- top -->
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="headertitle">
<div class="title">A C++ library for software defined radio (SDR). </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p>libsdr is a simple C++ library allowing to assemble software defined radio (SDR) applications easily. The library is a collection of (mostly) template classes implementing a wide varity of procssing nodes. By connecting these processing nodes, a stream-processing chain is constructed which turns raw input data into something meaningful.</p>
<p>Please note, I have written this library for my own amusement and to learn something about SDR. If you search for a more complete and efficient SDR library, consider GNU radio.</p>
<p>A processing node is either a <code><a class="el" href="classsdr_1_1_source.html" title="Generic source class. ">sdr::Source</a></code>, <code><a class="el" href="classsdr_1_1_sink.html" title="Typed sink. ">sdr::Sink</a></code>, both or may provide one or more sources or sinks. A source is always connected to a sink. Another important object is the <code><a class="el" href="classsdr_1_1_queue.html" title="Central message queue (singleton). ">sdr::Queue</a></code>. It is a singleton class that orchestrates the processing of the data. It may request further data from the sources once all present data has been processed. It also routes the date from the sources to the sinks.</p>
<h1><a class="anchor" id="intro"></a>
A practical introduction</h1>
<p>The following examples shows a trivial application that recods some audio from the systems default audio source and play it back. </p><div class="fragment"><div class="line"><span class="preprocessor">#include &lt;libsdr/sdr.hh&gt;</span></div>
<div class="line"></div>
<div class="line"><span class="keywordtype">int</span> main(<span class="keywordtype">int</span> argc, <span class="keywordtype">char</span> *argv[]) {</div>
<div class="line">  <span class="comment">// Initialize PortAudio system</span></div>
<div class="line">  <a class="code" href="classsdr_1_1_port_audio.html#aaec93bedb614d249c5d8f74138b55c3a">sdr::PortAudio::init</a>();</div>
<div class="line"></div>
<div class="line">  <span class="comment">// Create an audio source using PortAudio</span></div>
<div class="line">  <a class="code" href="classsdr_1_1_port_source.html">sdr::PortSource&lt;int16_t&gt;</a> source(44.1e3);</div>
<div class="line">  <span class="comment">// Create an audio sink using PortAudio</span></div>
<div class="line">  <a class="code" href="classsdr_1_1_port_sink.html">sdr::PortSink</a> sink;</div>
<div class="line"></div>
<div class="line">  <span class="comment">// Connect them</span></div>
<div class="line">  source.connect(&amp;sink);</div>
<div class="line"></div>
<div class="line">  <span class="comment">// Read new data from audio sink if queue is idle</span></div>
<div class="line">  <a class="code" href="classsdr_1_1_queue.html#ab4c57ac84eaa535fd412b3b7b7cfc816">sdr::Queue::get</a>().<a class="code" href="classsdr_1_1_queue.html#aedd07c29585deedd286266001c0e0356">addIdle</a>(&amp;source, &amp;<a class="code" href="classsdr_1_1_port_source.html">sdr::PortSource&lt;int16_t&gt;::next</a>);</div>
<div class="line"></div>
<div class="line">  <span class="comment">// Get and start queue</span></div>
<div class="line">  <a class="code" href="classsdr_1_1_queue.html#ab4c57ac84eaa535fd412b3b7b7cfc816">sdr::Queue::get</a>().<a class="code" href="classsdr_1_1_queue.html#a8e3298dff8edfc75648477ceb0426ffb">start</a>();</div>
<div class="line">  <span class="comment">// Wait for queue to stop</span></div>
<div class="line">  <a class="code" href="classsdr_1_1_queue.html#ab4c57ac84eaa535fd412b3b7b7cfc816">sdr::Queue::get</a>().<a class="code" href="classsdr_1_1_queue.html#a5017fc308c3be9793a4cc3e96c2eba12">wait</a>();</div>
<div class="line"></div>
<div class="line">  <span class="comment">// Terminate PortAudio system</span></div>
<div class="line">  <a class="code" href="classsdr_1_1_port_audio.html#a1b2c9c26f19d788e436806675f268ec3">sdr::PortAudio::terminate</a>();</div>
<div class="line"></div>
<div class="line">  <span class="comment">// done.</span></div>
<div class="line">  <span class="keywordflow">return</span> 0;</div>
<div class="line">}</div>
</div><!-- fragment --><p>First, the PortAudio system gets initialized.</p>
<p>Then, the audio source is constructed. The argument specifies the sample rate in Hz. Here a sample rate of 44100 Hz is used. The template argument of <code><a class="el" href="classsdr_1_1_port_source.html" title="PortAudio input stream as a Source. ">sdr::PortSource</a></code> specifies the input type. Here a signed 16bit integer is used. The audio source will have only one channel (mono).</p>
<p>The second node is the audio (playback) sink, which takes no arguments. It gets configured once the source is connected to the sink with <code>source.connect(&amp;sink)</code>.</p>
<p>In a next step, the sources <code>next</code> method gets connected to the "idle" signal of the queue. This is necessary as the audio source does not send data by its own. Whenever the <code>next</code> method gets called, the source will send a certain amount of captured data to the connected sinks. Some nodes will send data to the connected sinks without the need to explicit triggering. The <code><a class="el" href="classsdr_1_1_port_source.html" title="PortAudio input stream as a Source. ">sdr::PortSource</a></code> node, however, needs that explicit triggering. The "idle" event gets emitted once the queue gets empty, means whenever all data has been processes (here, played back).</p>
<p>As mentioned aboce, the queue is a singleton class. Means that for every process, there is exactly one instance of the queue. This singleton instance is accessed by calling the static method <code><a class="el" href="classsdr_1_1_queue.html#ab4c57ac84eaa535fd412b3b7b7cfc816" title="Get a reference to the global instance of the queue. ">sdr::Queue::get</a></code>. By calling <code><a class="el" href="classsdr_1_1_queue.html#a8e3298dff8edfc75648477ceb0426ffb" title="Enters the queue loop, if parallel=true was passed to get, exec will execute the queue loop in a sepa...">sdr::Queue::start</a></code>, the queue is started in a separate thread. This threads is responsible for all the processing of the data which allows to perform other tasks in the main thread, i.e. GUI stuff. A call to <code><a class="el" href="classsdr_1_1_queue.html#a5017fc308c3be9793a4cc3e96c2eba12" title="Wait for the queue to exit the queue loop. ">sdr::Queue::wait</a></code>, will wait for the processing thread to exit, which will never happen in that particular example.</p>
<p>The queue can be stopped by calling the <code><a class="el" href="classsdr_1_1_queue.html#aaf3a0e226ba622d762de9b32b3cbbb09" title="Signals the queue to stop processing. ">sdr::Queue::stop</a></code> method. This can be implemented for this example by the means of process signals.</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;signal.h&gt;</span></div>
<div class="line">...</div>
<div class="line"></div>
<div class="line">static <span class="keywordtype">void</span> __sigint_handler(<span class="keywordtype">int</span> signo) {</div>
<div class="line">  <span class="comment">// On SIGINT -&gt; stop queue properly</span></div>
<div class="line">  <a class="code" href="classsdr_1_1_queue.html#ab4c57ac84eaa535fd412b3b7b7cfc816">sdr::Queue::get</a>().<a class="code" href="classsdr_1_1_queue.html#aaf3a0e226ba622d762de9b32b3cbbb09">stop</a>();</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"><span class="keywordtype">int</span> main(<span class="keywordtype">int</span> argc, <span class="keywordtype">char</span> *argv[]) {</div>
<div class="line">  <span class="comment">// Register signal handler</span></div>
<div class="line">  signal(SIGINT, __sigint_handler);</div>
<div class="line">  ...</div>
<div class="line">}</div>
</div><!-- fragment --><p>Whenever a SIGINT is send to the process, i.e. by pressing CTRL+C, the <code><a class="el" href="classsdr_1_1_queue.html#aaf3a0e226ba622d762de9b32b3cbbb09" title="Signals the queue to stop processing. ">sdr::Queue::stop</a></code> method gets called. This will cause the processing thread of the queue to exit and the call to <code><a class="el" href="classsdr_1_1_queue.html#a5017fc308c3be9793a4cc3e96c2eba12" title="Wait for the queue to exit the queue loop. ">sdr::Queue::wait</a></code> to return.</p>
<h2><a class="anchor" id="example2"></a>
Queue less operation</h2>
<p>Sometimes, the queue is simply not needed. This is particularily the case if the data processing can happen in the main thread, i.e. if there is not GUI. The example above can be implemented without the Queue, as the main thread is just waiting for the processing thread to exit.</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;libsdr/sdr.hh&gt;</span></div>
<div class="line"></div>
<div class="line"><span class="keywordtype">int</span> main(<span class="keywordtype">int</span> argc, <span class="keywordtype">char</span> *argv[]) {</div>
<div class="line">  <span class="comment">// Initialize PortAudio system</span></div>
<div class="line">  <a class="code" href="classsdr_1_1_port_audio.html#aaec93bedb614d249c5d8f74138b55c3a">sdr::PortAudio::init</a>();</div>
<div class="line"></div>
<div class="line">  <span class="comment">// Create an audio source using PortAudio</span></div>
<div class="line">  <a class="code" href="classsdr_1_1_port_source.html">sdr::PortSource&lt;int16_t&gt;</a> source(44.1e3);</div>
<div class="line">  <span class="comment">// Create an audio sink using PortAudio</span></div>
<div class="line">  <a class="code" href="classsdr_1_1_port_sink.html">sdr::PortSink</a> sink;</div>
<div class="line"></div>
<div class="line">  <span class="comment">// Connect them directly</span></div>
<div class="line">  source.connect(&amp;sink, <span class="keyword">true</span>);</div>
<div class="line"></div>
<div class="line">  <span class="comment">// Loop to infinity7</span></div>
<div class="line">  <span class="keywordflow">while</span>(<span class="keyword">true</span>) { source.next(); }</div>
<div class="line"></div>
<div class="line">  <span class="comment">// Terminate PortAudio system</span></div>
<div class="line">  <a class="code" href="classsdr_1_1_port_audio.html#a1b2c9c26f19d788e436806675f268ec3">sdr::PortAudio::terminate</a>();</div>
<div class="line"></div>
<div class="line">  <span class="comment">// done.</span></div>
<div class="line">  <span class="keywordflow">return</span> 0;</div>
<div class="line">}</div>
</div><!-- fragment --><p>The major difference between the first example and this one, is the way how the nodes are connected. The <code><a class="el" href="classsdr_1_1_source.html#ac7df1faefb31e72e135eec3ecf539132" title="Connect this source to a sink. ">sdr::Source::connect</a></code> method takes an optional argument specifying wheter the source is connected directly to the sink or not. If <code>false</code> (the default) is specified, the data of the source will be send to the Queue first. In a direct connection (passing <code>true</code>), the source will send the data directly to the sink, bypassing the queue.</p>
<p>Instead of starting the processing thread of the queue, here the main thread is doing all the work by calling the <code>next</code> mehtod of the audio source.</p>
<h2><a class="anchor" id="logging"></a>
Log messages</h2>
<p>During configuration and operation, processing nodes will send log messages of different levels (DEBUG, INFO, WARNING, ERROR), which allow to debug the operation of the complete processing chain. These log messages are passed around using the build-in <code><a class="el" href="classsdr_1_1_logger.html" title="The logger class (singleton). ">sdr::Logger</a></code> class. To make them visible, a log handler must be installed.</p>
<div class="fragment"><div class="line"><span class="keywordtype">int</span> main(<span class="keywordtype">int</span> argc, <span class="keywordtype">char</span> *argv[]) {</div>
<div class="line">  ...</div>
<div class="line">  <span class="comment">// Install the log handler...</span></div>
<div class="line">  <a class="code" href="classsdr_1_1_logger.html#a9b12ce53593be134b7d7dea62607d22d">sdr::Logger::get</a>().<a class="code" href="classsdr_1_1_logger.html#a6c2ed5cb8cc27f85fc9fbf45602604e0">addHandler</a>(</div>
<div class="line">      <span class="keyword">new</span> <a class="code" href="classsdr_1_1_stream_log_handler.html">sdr::StreamLogHandler</a>(std::cerr, sdr::LOG_DEBUG));</div>
<div class="line">  ...</div>
<div class="line">}</div>
</div><!-- fragment --><p>Like the <code><a class="el" href="classsdr_1_1_queue.html" title="Central message queue (singleton). ">sdr::Queue</a></code>, the logger is also a singleton object, which can be obtained by <code><a class="el" href="classsdr_1_1_logger.html#a9b12ce53593be134b7d7dea62607d22d" title="Returns the singleton instance of the logger. ">sdr::Logger::get</a></code>. By calling <code><a class="el" href="classsdr_1_1_logger.html#a6c2ed5cb8cc27f85fc9fbf45602604e0" title="Adds a message handler. ">sdr::Logger::addHandler</a></code>, a new message handler is installed. In this example, a <code><a class="el" href="classsdr_1_1_stream_log_handler.html" title="Serializes log message into the specified stream. ">sdr::StreamLogHandler</a></code> instance is installed, which serializes the log messages into <code>std::cerr</code>.</p>
<h2><a class="anchor" id="intro_summary"></a>
In summary</h2>
<p>In summary, the complete example above using the queue including a singal handler to properly terminate the application by SIGINT and a log handler will look like</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;libsdr/sdr.hh&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;signal.h&gt;</span></div>
<div class="line"></div>
<div class="line"><span class="keyword">static</span> <span class="keywordtype">void</span> __sigint_handler(<span class="keywordtype">int</span> signo) {</div>
<div class="line">  <span class="comment">// On SIGINT -&gt; stop queue properly</span></div>
<div class="line">  <a class="code" href="classsdr_1_1_queue.html#ab4c57ac84eaa535fd412b3b7b7cfc816">sdr::Queue::get</a>().<a class="code" href="classsdr_1_1_queue.html#aaf3a0e226ba622d762de9b32b3cbbb09">stop</a>();</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"><span class="keywordtype">int</span> main(<span class="keywordtype">int</span> argc, <span class="keywordtype">char</span> *argv[]) {</div>
<div class="line">  <span class="comment">// Register signal handler</span></div>
<div class="line">  signal(SIGINT, __sigint_handler);</div>
<div class="line"></div>
<div class="line">  <span class="comment">// Initialize PortAudio system</span></div>
<div class="line">  <a class="code" href="classsdr_1_1_port_audio.html#aaec93bedb614d249c5d8f74138b55c3a">sdr::PortAudio::init</a>();</div>
<div class="line"></div>
<div class="line">  <span class="comment">// Create an audio source using PortAudio</span></div>
<div class="line">  <a class="code" href="classsdr_1_1_port_source.html">sdr::PortSource&lt;int16_t&gt;</a> source(44.1e3);</div>
<div class="line">  <span class="comment">// Create an audio sink using PortAudio</span></div>
<div class="line">  <a class="code" href="classsdr_1_1_port_sink.html">sdr::PortSink</a> sink;</div>
<div class="line"></div>
<div class="line">  <span class="comment">// Connect them</span></div>
<div class="line">  source.connect(&amp;sink);</div>
<div class="line"></div>
<div class="line">  <span class="comment">// Read new data from audio sink if queue is idle</span></div>
<div class="line">  <a class="code" href="classsdr_1_1_queue.html#ab4c57ac84eaa535fd412b3b7b7cfc816">sdr::Queue::get</a>().<a class="code" href="classsdr_1_1_queue.html#aedd07c29585deedd286266001c0e0356">addIdle</a>(&amp;source, &amp;<a class="code" href="classsdr_1_1_port_source.html">sdr::PortSource&lt;int16_t&gt;::next</a>);</div>
<div class="line"></div>
<div class="line">  <span class="comment">// Get and start queue</span></div>
<div class="line">  <a class="code" href="classsdr_1_1_queue.html#ab4c57ac84eaa535fd412b3b7b7cfc816">sdr::Queue::get</a>().<a class="code" href="classsdr_1_1_queue.html#a8e3298dff8edfc75648477ceb0426ffb">start</a>();</div>
<div class="line">  <span class="comment">// Wait for queue to stop</span></div>
<div class="line">  <a class="code" href="classsdr_1_1_queue.html#ab4c57ac84eaa535fd412b3b7b7cfc816">sdr::Queue::get</a>().<a class="code" href="classsdr_1_1_queue.html#a5017fc308c3be9793a4cc3e96c2eba12">wait</a>();</div>
<div class="line"></div>
<div class="line">  <span class="comment">// Terminate PortAudio system</span></div>
<div class="line">  <a class="code" href="classsdr_1_1_port_audio.html#a1b2c9c26f19d788e436806675f268ec3">sdr::PortAudio::terminate</a>();</div>
<div class="line"></div>
<div class="line">  <span class="comment">// done.</span></div>
<div class="line">  <span class="keywordflow">return</span> 0;</div>
<div class="line">}</div>
</div><!-- fragment --><p> This may appear quiet bloated for such a simple application. I designed the library to be rather explicit. No feature is implicit and hidden from the user. This turns simple examples like the one above quite bloated but it is imediately clear how the example works whithout any knowledge of "hidden features" and the complexity does not suddenly increases for non-trivial examples.</p>
<p>Finally, we may have a look at a more relaistic example implementing a FM broadcast receiver using a RTL2832 based USB dongle as the input source. </p><div class="fragment"><div class="line"><span class="preprocessor">#include &lt;libsdr/sdr.hh&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;signal.h&gt;</span></div>
<div class="line"></div>
<div class="line"><span class="keyword">static</span> <span class="keywordtype">void</span> __sigint_handler(<span class="keywordtype">int</span> signo) {</div>
<div class="line">  <span class="comment">// On SIGINT -&gt; stop queue properly</span></div>
<div class="line">  <a class="code" href="classsdr_1_1_queue.html#ab4c57ac84eaa535fd412b3b7b7cfc816">sdr::Queue::get</a>().<a class="code" href="classsdr_1_1_queue.html#aaf3a0e226ba622d762de9b32b3cbbb09">stop</a>();</div>
<div class="line">}</div>
<div class="line"></div>
<div class="line"><span class="keywordtype">int</span> main(<span class="keywordtype">int</span> argc, <span class="keywordtype">char</span> *argv[]) {</div>
<div class="line">  <span class="comment">// Register signal handler</span></div>
<div class="line">  signal(SIGINT, __sigint_handler);</div>
<div class="line"></div>
<div class="line">  <span class="comment">// Initialize PortAudio system</span></div>
<div class="line">  <a class="code" href="classsdr_1_1_port_audio.html#aaec93bedb614d249c5d8f74138b55c3a">sdr::PortAudio::init</a>();</div>
<div class="line"></div>
<div class="line">  <span class="comment">// Frequency of the FM station (in Hz)</span></div>
<div class="line">  <span class="keywordtype">double</span> freq = 100e6;</div>
<div class="line"></div>
<div class="line">  <span class="comment">// Create a RTL2832 input node</span></div>
<div class="line">  <a class="code" href="classsdr_1_1_r_t_l_source.html">sdr::RTLSource</a> src(freq);</div>
<div class="line">  <span class="comment">// Filter 100kHz around the center frequency (0) with an 16th order FIR filter and</span></div>
<div class="line">  <span class="comment">// subsample the result to a sample rate of approx. 100kHz.</span></div>
<div class="line">  <a class="code" href="classsdr_1_1_i_q_base_band.html">sdr::IQBaseBand&lt;int8_t&gt;</a> baseband(0, 100e3, 16, 0, 100e3);</div>
<div class="line">  <span class="comment">// FM demodulator, takes a complex int8_t stream and returns a real int16_t stream</span></div>
<div class="line">  <a class="code" href="classsdr_1_1_f_m_demod.html">sdr::FMDemod&lt;int8_t, int16_t&gt;</a> demod;</div>
<div class="line">  <span class="comment">// Deemphesize the result (actually part of the demodulation)</span></div>
<div class="line">  <a class="code" href="classsdr_1_1_f_m_deemph.html">sdr::FMDeemph&lt;int16_t&gt;</a> deemph;</div>
<div class="line">  <span class="comment">// Playback the final signal</span></div>
<div class="line">  <a class="code" href="classsdr_1_1_port_sink.html">sdr::PortSink</a> sink;</div>
<div class="line"></div>
<div class="line">  <span class="comment">// Connect signals</span></div>
<div class="line">  src.connect(&amp;baseband, <span class="keyword">true</span>);</div>
<div class="line">  baseband.connect(&amp;demod);</div>
<div class="line">  demod.<a class="code" href="classsdr_1_1_source.html#ac7df1faefb31e72e135eec3ecf539132">connect</a>(&amp;deemph);</div>
<div class="line">  deemph.<a class="code" href="classsdr_1_1_source.html#ac7df1faefb31e72e135eec3ecf539132">connect</a>(&amp;sink);</div>
<div class="line"></div>
<div class="line">  <span class="comment">// Connect start and stop signals of Queue to RTL2832 source</span></div>
<div class="line">  <a class="code" href="classsdr_1_1_queue.html#ab4c57ac84eaa535fd412b3b7b7cfc816">sdr::Queue::get</a>().<a class="code" href="classsdr_1_1_queue.html#ab17a48f85010dbb8ed25bd5aed143f19">addStart</a>(&amp;src, &amp;<a class="code" href="classsdr_1_1_r_t_l_source.html#a59aa8343fca4ff80948d28359d0a8b0a">sdr::RTLSource::start</a>);</div>
<div class="line">  <a class="code" href="classsdr_1_1_queue.html#ab4c57ac84eaa535fd412b3b7b7cfc816">sdr::Queue::get</a>().<a class="code" href="classsdr_1_1_queue.html#aa90eba90f16ed710d4a5214fa9b70354">addStop</a>(&amp;src, &amp;<a class="code" href="classsdr_1_1_r_t_l_source.html#a298ece19ede8427f9968a31108728d17">sdr::RTLSource::stop</a>);</div>
<div class="line"></div>
<div class="line">  <span class="comment">// Start queue</span></div>
<div class="line">  <a class="code" href="classsdr_1_1_queue.html#ab4c57ac84eaa535fd412b3b7b7cfc816">sdr::Queue::get</a>().<a class="code" href="classsdr_1_1_queue.html#a8e3298dff8edfc75648477ceb0426ffb">start</a>();</div>
<div class="line">  <span class="comment">// Wait for queue</span></div>
<div class="line">  <a class="code" href="classsdr_1_1_queue.html#ab4c57ac84eaa535fd412b3b7b7cfc816">sdr::Queue::get</a>().<a class="code" href="classsdr_1_1_queue.html#a5017fc308c3be9793a4cc3e96c2eba12">wait</a>();</div>
<div class="line"></div>
<div class="line">  <span class="comment">// Terminate PortAudio system</span></div>
<div class="line">  <a class="code" href="classsdr_1_1_port_audio.html#a1b2c9c26f19d788e436806675f268ec3">sdr::PortAudio::terminate</a>();</div>
<div class="line"></div>
<div class="line">  <span class="comment">// Done...</span></div>
<div class="line">  <span class="keywordflow">return</span> 0;</div>
<div class="line">}</div>
</div><!-- fragment --> </div></div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Mon Jun 1 2015 11:40:53 for libsdr by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.9.1
</small></address>
</body>
</html>
