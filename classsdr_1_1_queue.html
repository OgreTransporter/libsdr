<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.6"/>
<title>libsdr: sdr::Queue Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { searchBox.OnSelectItem(0); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">libsdr
   &#160;<span id="projectnumber">0.1.0</span>
   </div>
   <div id="projectbrief">A simple SDR library</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.6 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Class&#160;List</span></a></li>
      <li><a href="classes.html"><span>Class&#160;Index</span></a></li>
      <li><a href="hierarchy.html"><span>Class&#160;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&#160;Members</span></a></li>
    </ul>
  </div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Classes</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Typedefs</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&#160;</span>Enumerations</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&#160;</span>Enumerator</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(7)"><span class="SelectionMark">&#160;</span>Pages</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><b>sdr</b></li><li class="navelem"><a class="el" href="classsdr_1_1_queue.html">Queue</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-static-methods">Static Public Member Functions</a> &#124;
<a href="#pro-methods">Protected Member Functions</a> &#124;
<a href="#pro-attribs">Protected Attributes</a> &#124;
<a href="classsdr_1_1_queue-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">sdr::Queue Class Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>Central message queue (singleton).  
 <a href="classsdr_1_1_queue.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="queue_8hh_source.html">queue.hh</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsdr_1_1_queue_1_1_message.html">Message</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The internal used message type.  <a href="classsdr_1_1_queue_1_1_message.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a00d119db8fa3050da37746e82cbcf94f"><td class="memItemLeft" align="right" valign="top">virtual&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsdr_1_1_queue.html#a00d119db8fa3050da37746e82cbcf94f">~Queue</a> ()</td></tr>
<tr class="memdesc:a00d119db8fa3050da37746e82cbcf94f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destructor.  <a href="#a00d119db8fa3050da37746e82cbcf94f">More...</a><br/></td></tr>
<tr class="separator:a00d119db8fa3050da37746e82cbcf94f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af5081696c758e00520bf670fffad6918"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsdr_1_1_queue.html#af5081696c758e00520bf670fffad6918">send</a> (const <a class="el" href="classsdr_1_1_raw_buffer.html">RawBuffer</a> &amp;buffer, <a class="el" href="classsdr_1_1_sink_base.html">SinkBase</a> *sink, bool allow_overwrite=false)</td></tr>
<tr class="memdesc:af5081696c758e00520bf670fffad6918"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds a buffer and its receiver to the queue.  <a href="#af5081696c758e00520bf670fffad6918">More...</a><br/></td></tr>
<tr class="separator:af5081696c758e00520bf670fffad6918"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8e3298dff8edfc75648477ceb0426ffb"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsdr_1_1_queue.html#a8e3298dff8edfc75648477ceb0426ffb">start</a> ()</td></tr>
<tr class="memdesc:a8e3298dff8edfc75648477ceb0426ffb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enters the queue loop, if <code>parallel=true</code> was passed to <code>get</code>, <code>exec</code> will execute the queue loop in a separate thread and returns immediately.  <a href="#a8e3298dff8edfc75648477ceb0426ffb">More...</a><br/></td></tr>
<tr class="separator:a8e3298dff8edfc75648477ceb0426ffb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaf3a0e226ba622d762de9b32b3cbbb09"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsdr_1_1_queue.html#aaf3a0e226ba622d762de9b32b3cbbb09">stop</a> ()</td></tr>
<tr class="memdesc:aaf3a0e226ba622d762de9b32b3cbbb09"><td class="mdescLeft">&#160;</td><td class="mdescRight">Signals the queue to stop processing.  <a href="#aaf3a0e226ba622d762de9b32b3cbbb09">More...</a><br/></td></tr>
<tr class="separator:aaf3a0e226ba622d762de9b32b3cbbb09"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5017fc308c3be9793a4cc3e96c2eba12"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsdr_1_1_queue.html#a5017fc308c3be9793a4cc3e96c2eba12">wait</a> ()</td></tr>
<tr class="memdesc:a5017fc308c3be9793a4cc3e96c2eba12"><td class="mdescLeft">&#160;</td><td class="mdescRight">Wait for the queue to exit the queue loop.  <a href="#a5017fc308c3be9793a4cc3e96c2eba12">More...</a><br/></td></tr>
<tr class="separator:a5017fc308c3be9793a4cc3e96c2eba12"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae6682efa4e7917e642e28f538310b65d"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsdr_1_1_queue.html#ae6682efa4e7917e642e28f538310b65d">isStopped</a> () const </td></tr>
<tr class="memdesc:ae6682efa4e7917e642e28f538310b65d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if the queue loop is stopped.  <a href="#ae6682efa4e7917e642e28f538310b65d">More...</a><br/></td></tr>
<tr class="separator:ae6682efa4e7917e642e28f538310b65d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a29564db70cb6f3a0cfd04a3cb95476e4"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsdr_1_1_queue.html#a29564db70cb6f3a0cfd04a3cb95476e4">isRunning</a> () const </td></tr>
<tr class="memdesc:a29564db70cb6f3a0cfd04a3cb95476e4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if the queue loop is running.  <a href="#a29564db70cb6f3a0cfd04a3cb95476e4">More...</a><br/></td></tr>
<tr class="separator:a29564db70cb6f3a0cfd04a3cb95476e4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aedd07c29585deedd286266001c0e0356"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:aedd07c29585deedd286266001c0e0356"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classsdr_1_1_queue.html#aedd07c29585deedd286266001c0e0356">addIdle</a> (T *instance, void(T::*function)(void))</td></tr>
<tr class="memdesc:aedd07c29585deedd286266001c0e0356"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds a callback to the idle event.  <a href="#aedd07c29585deedd286266001c0e0356">More...</a><br/></td></tr>
<tr class="separator:aedd07c29585deedd286266001c0e0356"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a390125515b339ae54ee586cb4e162131"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:a390125515b339ae54ee586cb4e162131"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classsdr_1_1_queue.html#a390125515b339ae54ee586cb4e162131">remIdle</a> (T *instance)</td></tr>
<tr class="memdesc:a390125515b339ae54ee586cb4e162131"><td class="mdescLeft">&#160;</td><td class="mdescRight">Removes all callbacks of the given instance from the idle signal.  <a href="#a390125515b339ae54ee586cb4e162131">More...</a><br/></td></tr>
<tr class="separator:a390125515b339ae54ee586cb4e162131"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab17a48f85010dbb8ed25bd5aed143f19"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:ab17a48f85010dbb8ed25bd5aed143f19"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classsdr_1_1_queue.html#ab17a48f85010dbb8ed25bd5aed143f19">addStart</a> (T *instance, void(T::*function)(void))</td></tr>
<tr class="memdesc:ab17a48f85010dbb8ed25bd5aed143f19"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds a callback to the start event.  <a href="#ab17a48f85010dbb8ed25bd5aed143f19">More...</a><br/></td></tr>
<tr class="separator:ab17a48f85010dbb8ed25bd5aed143f19"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9a3ea601975c9890958759914ce19f88"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:a9a3ea601975c9890958759914ce19f88"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classsdr_1_1_queue.html#a9a3ea601975c9890958759914ce19f88">remStart</a> (T *instance)</td></tr>
<tr class="memdesc:a9a3ea601975c9890958759914ce19f88"><td class="mdescLeft">&#160;</td><td class="mdescRight">Removes all callbacks of the given instance from the start signal.  <a href="#a9a3ea601975c9890958759914ce19f88">More...</a><br/></td></tr>
<tr class="separator:a9a3ea601975c9890958759914ce19f88"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa90eba90f16ed710d4a5214fa9b70354"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:aa90eba90f16ed710d4a5214fa9b70354"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classsdr_1_1_queue.html#aa90eba90f16ed710d4a5214fa9b70354">addStop</a> (T *instance, void(T::*function)(void))</td></tr>
<tr class="memdesc:aa90eba90f16ed710d4a5214fa9b70354"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds a callback to the stop event.  <a href="#aa90eba90f16ed710d4a5214fa9b70354">More...</a><br/></td></tr>
<tr class="separator:aa90eba90f16ed710d4a5214fa9b70354"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6d9e3d5fc2007a77d37f4a070159ba5b"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:a6d9e3d5fc2007a77d37f4a070159ba5b"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classsdr_1_1_queue.html#a6d9e3d5fc2007a77d37f4a070159ba5b">remStop</a> (T *instance)</td></tr>
<tr class="memdesc:a6d9e3d5fc2007a77d37f4a070159ba5b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Removes all callbacks of the given instance from the stop signal.  <a href="#a6d9e3d5fc2007a77d37f4a070159ba5b">More...</a><br/></td></tr>
<tr class="separator:a6d9e3d5fc2007a77d37f4a070159ba5b"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-static-methods"></a>
Static Public Member Functions</h2></td></tr>
<tr class="memitem:ab4c57ac84eaa535fd412b3b7b7cfc816"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classsdr_1_1_queue.html">Queue</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsdr_1_1_queue.html#ab4c57ac84eaa535fd412b3b7b7cfc816">get</a> ()</td></tr>
<tr class="memdesc:ab4c57ac84eaa535fd412b3b7b7cfc816"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a reference to the global instance of the queue.  <a href="#ab4c57ac84eaa535fd412b3b7b7cfc816">More...</a><br/></td></tr>
<tr class="separator:ab4c57ac84eaa535fd412b3b7b7cfc816"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-methods"></a>
Protected Member Functions</h2></td></tr>
<tr class="memitem:a7cfca3637d57c4a9e37351b3426ffd40"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsdr_1_1_queue.html#a7cfca3637d57c4a9e37351b3426ffd40">Queue</a> ()</td></tr>
<tr class="memdesc:a7cfca3637d57c4a9e37351b3426ffd40"><td class="mdescLeft">&#160;</td><td class="mdescRight">Hidden constructor, use <code>get</code> to get the singleton instance.  <a href="#a7cfca3637d57c4a9e37351b3426ffd40">More...</a><br/></td></tr>
<tr class="separator:a7cfca3637d57c4a9e37351b3426ffd40"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a40e974a7b7f2dfdc22a13eb88390bab1"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsdr_1_1_queue.html#a40e974a7b7f2dfdc22a13eb88390bab1">_main</a> ()</td></tr>
<tr class="memdesc:a40e974a7b7f2dfdc22a13eb88390bab1"><td class="mdescLeft">&#160;</td><td class="mdescRight">The actual queue loop.  <a href="#a40e974a7b7f2dfdc22a13eb88390bab1">More...</a><br/></td></tr>
<tr class="separator:a40e974a7b7f2dfdc22a13eb88390bab1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3f0e1694388e1bc6091b2f69c9f47093"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsdr_1_1_queue.html#a3f0e1694388e1bc6091b2f69c9f47093">_signalIdle</a> ()</td></tr>
<tr class="memdesc:a3f0e1694388e1bc6091b2f69c9f47093"><td class="mdescLeft">&#160;</td><td class="mdescRight">Emits the idle signal.  <a href="#a3f0e1694388e1bc6091b2f69c9f47093">More...</a><br/></td></tr>
<tr class="separator:a3f0e1694388e1bc6091b2f69c9f47093"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a676426643d21b8f4070353dd732c0327"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsdr_1_1_queue.html#a676426643d21b8f4070353dd732c0327">_signalStart</a> ()</td></tr>
<tr class="memdesc:a676426643d21b8f4070353dd732c0327"><td class="mdescLeft">&#160;</td><td class="mdescRight">Emits the start signal.  <a href="#a676426643d21b8f4070353dd732c0327">More...</a><br/></td></tr>
<tr class="separator:a676426643d21b8f4070353dd732c0327"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abdd5b0e151e635a0c7b17522f51fd7bd"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsdr_1_1_queue.html#abdd5b0e151e635a0c7b17522f51fd7bd">_signalStop</a> ()</td></tr>
<tr class="memdesc:abdd5b0e151e635a0c7b17522f51fd7bd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Emits the stop signal.  <a href="#abdd5b0e151e635a0c7b17522f51fd7bd">More...</a><br/></td></tr>
<tr class="separator:abdd5b0e151e635a0c7b17522f51fd7bd"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-attribs"></a>
Protected Attributes</h2></td></tr>
<tr class="memitem:a737a26f99e37b820256f1116f58c5f12"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsdr_1_1_queue.html#a737a26f99e37b820256f1116f58c5f12">_running</a></td></tr>
<tr class="memdesc:a737a26f99e37b820256f1116f58c5f12"><td class="mdescLeft">&#160;</td><td class="mdescRight">While this is true, the queue loop is executed.  <a href="#a737a26f99e37b820256f1116f58c5f12">More...</a><br/></td></tr>
<tr class="separator:a737a26f99e37b820256f1116f58c5f12"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac9e0bc546b7bd19be55140d2bcec535a"><td class="memItemLeft" align="right" valign="top">pthread_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsdr_1_1_queue.html#ac9e0bc546b7bd19be55140d2bcec535a">_thread</a></td></tr>
<tr class="memdesc:ac9e0bc546b7bd19be55140d2bcec535a"><td class="mdescLeft">&#160;</td><td class="mdescRight">If <code>_parallel</code> is true, the thread of the queue loop.  <a href="#ac9e0bc546b7bd19be55140d2bcec535a">More...</a><br/></td></tr>
<tr class="separator:ac9e0bc546b7bd19be55140d2bcec535a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a258a5d1adc7edb81cebf19470a55d646"><td class="memItemLeft" align="right" valign="top">pthread_mutex_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsdr_1_1_queue.html#a258a5d1adc7edb81cebf19470a55d646">_queue_lock</a></td></tr>
<tr class="memdesc:a258a5d1adc7edb81cebf19470a55d646"><td class="mdescLeft">&#160;</td><td class="mdescRight">The queue mutex.  <a href="#a258a5d1adc7edb81cebf19470a55d646">More...</a><br/></td></tr>
<tr class="separator:a258a5d1adc7edb81cebf19470a55d646"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afd7a65823156e0d1a4512542674883a4"><td class="memItemLeft" align="right" valign="top">pthread_cond_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsdr_1_1_queue.html#afd7a65823156e0d1a4512542674883a4">_queue_cond</a></td></tr>
<tr class="memdesc:afd7a65823156e0d1a4512542674883a4"><td class="mdescLeft">&#160;</td><td class="mdescRight">The queue condition.  <a href="#afd7a65823156e0d1a4512542674883a4">More...</a><br/></td></tr>
<tr class="separator:afd7a65823156e0d1a4512542674883a4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae686ad5be0afd27a38a1b8d3d15e08c3"><td class="memItemLeft" align="right" valign="top">std::list&lt; <a class="el" href="classsdr_1_1_queue_1_1_message.html">Message</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsdr_1_1_queue.html#ae686ad5be0afd27a38a1b8d3d15e08c3">_queue</a></td></tr>
<tr class="memdesc:ae686ad5be0afd27a38a1b8d3d15e08c3"><td class="mdescLeft">&#160;</td><td class="mdescRight">The message queue.  <a href="#ae686ad5be0afd27a38a1b8d3d15e08c3">More...</a><br/></td></tr>
<tr class="separator:ae686ad5be0afd27a38a1b8d3d15e08c3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a31f323fab261acd8456b68dc6ed188bf"><td class="memItemLeft" align="right" valign="top">std::list&lt; <a class="el" href="classsdr_1_1_delegate_interface.html">DelegateInterface</a> * &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsdr_1_1_queue.html#a31f323fab261acd8456b68dc6ed188bf">_idle</a></td></tr>
<tr class="memdesc:a31f323fab261acd8456b68dc6ed188bf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Idle event callbacks.  <a href="#a31f323fab261acd8456b68dc6ed188bf">More...</a><br/></td></tr>
<tr class="separator:a31f323fab261acd8456b68dc6ed188bf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a778063ea21baba61c0e2ede519fb0da8"><td class="memItemLeft" align="right" valign="top">std::list&lt; <a class="el" href="classsdr_1_1_delegate_interface.html">DelegateInterface</a> * &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsdr_1_1_queue.html#a778063ea21baba61c0e2ede519fb0da8">_onStart</a></td></tr>
<tr class="memdesc:a778063ea21baba61c0e2ede519fb0da8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Start event callbacks.  <a href="#a778063ea21baba61c0e2ede519fb0da8">More...</a><br/></td></tr>
<tr class="separator:a778063ea21baba61c0e2ede519fb0da8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a88450462f8ca5c2a68bdee5e88ae6768"><td class="memItemLeft" align="right" valign="top">std::list&lt; <a class="el" href="classsdr_1_1_delegate_interface.html">DelegateInterface</a> * &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsdr_1_1_queue.html#a88450462f8ca5c2a68bdee5e88ae6768">_onStop</a></td></tr>
<tr class="memdesc:a88450462f8ca5c2a68bdee5e88ae6768"><td class="mdescLeft">&#160;</td><td class="mdescRight">Stop event callbacks.  <a href="#a88450462f8ca5c2a68bdee5e88ae6768">More...</a><br/></td></tr>
<tr class="separator:a88450462f8ca5c2a68bdee5e88ae6768"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Central message queue (singleton). </p>
<p>Must be created before any other SDR object is constructed. The queue collects all buffers for processing and routes them to their destination. The queue loop can either be run in a separate thread by passing <code>parallel=true</code> to the factory method <code>get</code>. In this case, the <code>exec</code> method will return immediately. Otherwise, the queue loop will be executed in the thread calling <code>exec</code> which blocks until the queue is stopped by a call to <code>stop</code>. </p>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a class="anchor" id="a7cfca3637d57c4a9e37351b3426ffd40"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Queue::Queue </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Hidden constructor, use <code>get</code> to get the singleton instance. </p>

</div>
</div>
<a class="anchor" id="a00d119db8fa3050da37746e82cbcf94f"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Queue::~Queue </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Destructor. </p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a class="anchor" id="a40e974a7b7f2dfdc22a13eb88390bab1"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Queue::_main </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The actual queue loop. </p>

</div>
</div>
<a class="anchor" id="a3f0e1694388e1bc6091b2f69c9f47093"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Queue::_signalIdle </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Emits the idle signal. </p>

</div>
</div>
<a class="anchor" id="a676426643d21b8f4070353dd732c0327"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Queue::_signalStart </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Emits the start signal. </p>

</div>
</div>
<a class="anchor" id="abdd5b0e151e635a0c7b17522f51fd7bd"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Queue::_signalStop </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Emits the stop signal. </p>

</div>
</div>
<a class="anchor" id="aedd07c29585deedd286266001c0e0356"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void sdr::Queue::addIdle </td>
          <td>(</td>
          <td class="paramtype">T *&#160;</td>
          <td class="paramname"><em>instance</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void(T::*)(void)&#160;</td>
          <td class="paramname"><em>function</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Adds a callback to the idle event. </p>
<p>The method gets called repeatedly while the queue looop is idle, means that there are no messages to be processed. This can be used to trigger an input source to read more data. </p>

</div>
</div>
<a class="anchor" id="ab17a48f85010dbb8ed25bd5aed143f19"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void sdr::Queue::addStart </td>
          <td>(</td>
          <td class="paramtype">T *&#160;</td>
          <td class="paramname"><em>instance</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void(T::*)(void)&#160;</td>
          <td class="paramname"><em>function</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Adds a callback to the start event. </p>
<p>The method gets called once the queue loop is started. </p>

</div>
</div>
<a class="anchor" id="aa90eba90f16ed710d4a5214fa9b70354"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void sdr::Queue::addStop </td>
          <td>(</td>
          <td class="paramtype">T *&#160;</td>
          <td class="paramname"><em>instance</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void(T::*)(void)&#160;</td>
          <td class="paramname"><em>function</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Adds a callback to the stop event. </p>
<p>The method gets called once the queue loop is stopped. </p>

</div>
</div>
<a class="anchor" id="ab4c57ac84eaa535fd412b3b7b7cfc816"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classsdr_1_1_queue.html">Queue</a> &amp; Queue::get </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get a reference to the global instance of the queue. </p>
<p>If <code>parallel</code> is <code>true</code>, the queue will be constructed in parallel mode, means the queue loop will be executed in a separate thread. Please note that this option is only used in the first call, when the singleton instance of the queue is created. </p>

</div>
</div>
<a class="anchor" id="a29564db70cb6f3a0cfd04a3cb95476e4"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Queue::isRunning </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns true if the queue loop is running. </p>

</div>
</div>
<a class="anchor" id="ae6682efa4e7917e642e28f538310b65d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool Queue::isStopped </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns true if the queue loop is stopped. </p>

</div>
</div>
<a class="anchor" id="a390125515b339ae54ee586cb4e162131"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void sdr::Queue::remIdle </td>
          <td>(</td>
          <td class="paramtype">T *&#160;</td>
          <td class="paramname"><em>instance</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Removes all callbacks of the given instance from the idle signal. </p>

</div>
</div>
<a class="anchor" id="a9a3ea601975c9890958759914ce19f88"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void sdr::Queue::remStart </td>
          <td>(</td>
          <td class="paramtype">T *&#160;</td>
          <td class="paramname"><em>instance</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Removes all callbacks of the given instance from the start signal. </p>

</div>
</div>
<a class="anchor" id="a6d9e3d5fc2007a77d37f4a070159ba5b"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void sdr::Queue::remStop </td>
          <td>(</td>
          <td class="paramtype">T *&#160;</td>
          <td class="paramname"><em>instance</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Removes all callbacks of the given instance from the stop signal. </p>

</div>
</div>
<a class="anchor" id="af5081696c758e00520bf670fffad6918"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Queue::send </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classsdr_1_1_raw_buffer.html">RawBuffer</a> &amp;&#160;</td>
          <td class="paramname"><em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classsdr_1_1_sink_base.html">SinkBase</a> *&#160;</td>
          <td class="paramname"><em>sink</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>allow_overwrite</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Adds a buffer and its receiver to the queue. </p>
<p>If <code>allow_overwrite</code> is <code>true</code>, the the receiver is allowed to overwrite the content of the buffer. </p>

</div>
</div>
<a class="anchor" id="a8e3298dff8edfc75648477ceb0426ffb"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Queue::start </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Enters the queue loop, if <code>parallel=true</code> was passed to <code>get</code>, <code>exec</code> will execute the queue loop in a separate thread and returns immediately. </p>
<p>Otherwise, <code>exec</code> will block until the queue is stopped. </p>

</div>
</div>
<a class="anchor" id="aaf3a0e226ba622d762de9b32b3cbbb09"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Queue::stop </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Signals the queue to stop processing. </p>

</div>
</div>
<a class="anchor" id="a5017fc308c3be9793a4cc3e96c2eba12"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Queue::wait </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Wait for the queue to exit the queue loop. </p>

</div>
</div>
<h2 class="groupheader">Member Data Documentation</h2>
<a class="anchor" id="a31f323fab261acd8456b68dc6ed188bf"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::list&lt;<a class="el" href="classsdr_1_1_delegate_interface.html">DelegateInterface</a> *&gt; sdr::Queue::_idle</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Idle event callbacks. </p>

</div>
</div>
<a class="anchor" id="a778063ea21baba61c0e2ede519fb0da8"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::list&lt;<a class="el" href="classsdr_1_1_delegate_interface.html">DelegateInterface</a> *&gt; sdr::Queue::_onStart</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Start event callbacks. </p>

</div>
</div>
<a class="anchor" id="a88450462f8ca5c2a68bdee5e88ae6768"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::list&lt;<a class="el" href="classsdr_1_1_delegate_interface.html">DelegateInterface</a> *&gt; sdr::Queue::_onStop</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Stop event callbacks. </p>

</div>
</div>
<a class="anchor" id="ae686ad5be0afd27a38a1b8d3d15e08c3"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::list&lt;<a class="el" href="classsdr_1_1_queue_1_1_message.html">Message</a>&gt; sdr::Queue::_queue</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The message queue. </p>

</div>
</div>
<a class="anchor" id="afd7a65823156e0d1a4512542674883a4"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">pthread_cond_t sdr::Queue::_queue_cond</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The queue condition. </p>

</div>
</div>
<a class="anchor" id="a258a5d1adc7edb81cebf19470a55d646"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">pthread_mutex_t sdr::Queue::_queue_lock</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The queue mutex. </p>

</div>
</div>
<a class="anchor" id="a737a26f99e37b820256f1116f58c5f12"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool sdr::Queue::_running</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>While this is true, the queue loop is executed. </p>

</div>
</div>
<a class="anchor" id="ac9e0bc546b7bd19be55140d2bcec535a"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">pthread_t sdr::Queue::_thread</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>If <code>_parallel</code> is true, the thread of the queue loop. </p>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li>/home/hannes/sdr/libsdr/src/<a class="el" href="queue_8hh_source.html">queue.hh</a></li>
<li>/home/hannes/sdr/libsdr/src/queue.cc</li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Wed May 27 2015 14:36:14 for libsdr by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.6
</small></address>
</body>
</html>
